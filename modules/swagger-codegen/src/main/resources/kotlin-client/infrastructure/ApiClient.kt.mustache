package {{packageName}}.infrastructure

import okhttp3.HttpUrl.Companion.toHttpUrlOrNull
import okhttp3.MediaType.Companion.toMediaTypeOrNull
import okhttp3.MultipartBody
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody
import okhttp3.RequestBody.Companion.asRequestBody
import okhttp3.RequestBody.Companion.toRequestBody
import okhttp3.Response
import java.io.File
import java.io.IOException
import java.util.regex.Pattern

open class ApiClient(val baseUrl: String) {
    companion object {
        protected const val ContentType = "Content-Type"
        protected const val Accept = "Accept"
        protected const val JsonMediaType = "application/json"
        protected const val FormDataMediaType = "multipart/form-data"
        protected const val XmlMediaType = "application/xml"

        @JvmStatic
        val client by lazy {
            builder.build()
        }

        @JvmStatic
        val builder: OkHttpClient.Builder = OkHttpClient.Builder()

        @JvmStatic
        var defaultHeaders: MutableMap<String, String> by ApplicationDelegates.setOnce(mutableMapOf(ContentType to JsonMediaType, Accept to JsonMediaType))

        @JvmStatic
        val jsonHeaders: MutableMap<String, String> = mutableMapOf(ContentType to JsonMediaType, Accept to JsonMediaType)
    }

	protected inline fun <reified T> requestBody(content: T, mediaType: String = JsonMediaType): RequestBody {
		if(content is File) {
		return content.asRequestBody(mediaType.toMediaTypeOrNull())
		}

		if(mediaType == FormDataMediaType) {
			val requestBodyBuilder = MultipartBody.Builder().setType(MultipartBody.FORM)

			// content's type *must* be Map<String, Any>
			@Suppress("UNCHECKED_CAST")
			(content as Map<String,Any>).forEach { (key, value) ->
				if(value is File) {
					val fileMediaType = "application/octet-stream".toMediaTypeOrNull()
					requestBodyBuilder.addFormDataPart(
						key,
						value.name,
						value.asRequestBody(fileMediaType)
					)
				}

				if( value is String ){
				requestBodyBuilder.addFormDataPart(key, value)
				}

				TODO("Handle other types inside FormDataMediaType")
			}

			return requestBodyBuilder.build()
		}

		if(mediaType == JsonMediaType) {
			return Serializer.moshi.adapter(T::class.java).toJson(content).toRequestBody(mediaType.toMediaTypeOrNull())
		}

		if (mediaType == XmlMediaType) {
			TODO("xml not currently supported.")
		}

		TODO("requestBody currently only supports JSON body and File body.")
    }

	protected inline fun <reified T: Any?> responseBody(response: Response): T? {
		if(response.body == null) return null

		if(T::class.java == java.io.File::class.java){
			return downloadFileFromResponse(response) as T
		} else if(T::class == Unit::class) {
			return Unit as T
		}

		val contentType = response.headers["Content-Type"] ?: JsonMediaType
		return when {
			isJsonMime(contentType) -> Serializer.moshi.adapter(T::class.java).fromJson(response.body!!.source())
			contentType.startsWith("text/") -> response.body.toString() as T
			contentType == "application/xml" -> response.body.toString() as T
			else -> TODO("Fill in more types!")
		}
	}


    protected fun isJsonMime(mime: String?): Boolean {
        val jsonMime = "(?i)^(application/json|[^;/ \t]+/[^;/ \t]+[+]json)[ \t]*(;.*)?$"
        return mime != null && (mime.matches(jsonMime.toRegex()) || mime == "*/*")
    }

	protected inline fun <reified T: Any?> request(requestConfig: RequestConfig, body : Any? = null): ApiInfrastructureResponse<T?> {
        val httpUrl = baseUrl.toHttpUrlOrNull() ?: throw IllegalStateException("baseUrl is invalid.")

        var urlBuilder = httpUrl.newBuilder()
                .addPathSegments(requestConfig.path.trimStart('/'))

        requestConfig.query.forEach { query ->
            query.value.forEach { queryValue ->
                urlBuilder = urlBuilder.addQueryParameter(query.key, queryValue)
            }
        }

        val url = urlBuilder.build()
        val headers = defaultHeaders + requestConfig.headers

		check(headers[ContentType] ?: "" != "") { "Missing Content-Type header. This is required." }
		check(headers[Accept] ?: "" != "") { "Missing Accept header. This is required." }

        // TODO: support multiple contentType,accept options here.
        val contentType = (headers[ContentType] as String).substringBefore(";").toLowerCase()
        var request : Request.Builder =  when (requestConfig.method) {
            RequestMethod.DELETE -> Request.Builder().url(url).delete()
            RequestMethod.GET -> Request.Builder().url(url)
            RequestMethod.HEAD -> Request.Builder().url(url).head()
            RequestMethod.PATCH -> Request.Builder().url(url).patch(requestBody(body, contentType))
            RequestMethod.PUT -> Request.Builder().url(url).put(requestBody(body, contentType))
            RequestMethod.POST -> Request.Builder().url(url).post(requestBody(body, contentType))
            RequestMethod.OPTIONS -> Request.Builder().url(url).method("OPTIONS", null)
        }

        headers.forEach { header -> request = request.addHeader(header.key, header.value) }

        val realRequest = request.build()
        val response = client.newCall(realRequest).execute()

        // TODO: handle specific mapping types. e.g. Map<int, Class<?>>
        when {
            response.isRedirect -> return Redirection(
                    response.code,
                    response.headers.toMultimap()
            )
            response.isInformational -> return Informational(
                    response.message,
                    response.code,
                    response.headers.toMultimap()
            )
            response.isSuccessful -> return Success(
                    responseBody(response),
                    response.code,
                    response.headers.toMultimap()
            )
            response.isClientError -> return ClientError(
                    response.body?.string(),
                    response.code,
                    response.headers.toMultimap()
            )
            else -> return ServerError(
                    null,
                    response.body?.string(),
                    response.code,
                    response.headers.toMultimap()
            )
        }
    }

    @Throws(IOException::class)
    fun downloadFileFromResponse(response: Response): File {
        val file = prepareDownloadFile(response)

        response.body?.byteStream().use{ input ->
            File(file.path).outputStream().use { input?.copyTo(it) }
        }

        return file
    }

    @Throws(IOException::class)
    fun prepareDownloadFile(response: Response): File {
        var filename: String? = null
		val contentDisposition = response.headers["Content-Disposition"]

        if(contentDisposition != null && contentDisposition != ""){
            val pattern = Pattern.compile("filename=['\"]?([^'\"\\s]+)['\"]?")
            val matcher = pattern.matcher(contentDisposition)

            if (matcher.find())
                filename = matcher.group(1)
        }
        var prefix: String
        var suffix: String? = null

        if (filename == null) {
            prefix = "download-"
            suffix = ""
        } else {
            val pos = filename.lastIndexOf('.')

            if (pos == -1) {
				prefix = "$filename-";
            } else {
                prefix = filename.substring(0, pos) + "-"
                suffix = filename.substring(pos)
            }
            // File.createTempFile requires the prefix to be at least three characters long
        if (prefix.length < 3)
            prefix = "download-"
        }

        return File.createTempFile(prefix, suffix)
    }
}